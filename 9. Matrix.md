# GitHub Actions: Running a Job Multiple Times Using a Matrix

## Matrix Strategy

The matrix strategy lets you run a job multiple times with different combinations of variables. This is useful for testing across multiple operating systems, language versions, or other configurations.


## ‚úÖ What is a Matrix Strategy in GitHub Actions?

Matrix allows you to run a job **multiple times in parallel**, varying parameters like:

* OS
* Environment (dev/staging/prod)
* Versions (Java, Python, etc.)

This is great for:

* Testing across multiple environments
* Deploying to multiple regions
* Running the same logic against multiple configs

---

## üß™ Real-World Example: Deploy to Multiple Environments

Imagine you want to **run a shell-based deploy job to 3 environments** ‚Äî `dev`, `staging`, and `prod`.

```yaml
name: Multi-Env Deployment using Matrix

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        environment: [dev, staging, prod]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Deploy to ${{ matrix.environment }}
        run: |
          echo "Starting deployment to ${{ matrix.environment }} environment"
          sleep 3
          echo "Deployment to ${{ matrix.environment }} completed successfully"
```

---

### üßæ Explanation:

* `matrix.environment` creates **3 parallel jobs**:
  one each for `dev`, `staging`, and `prod`.
* Each job will run the same steps, but with its **own value of `matrix.environment`**.
* You can customize steps per environment if needed using `if:` conditionals.

---

### ‚úÖ Output:

You will see:

* One job for `dev`
* One job for `staging`
* One job for `prod`
  All running **independently and in parallel**.

---

## Complete Example (Non-NPM)

Here's a practical example testing a Python script across different operating systems and Python versions:

```yaml
name: Multi-Platform Python Tests

on: [push]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ["3.8", "3.9", "3.10"]
        include:
          - os: ubuntu-latest
            extra-pkg: "python3-dev"
          - os: macos-latest
            extra-pkg: "openssl"
          - os: windows-latest
            extra-pkg: "python"
        exclude:
          - os: windows-latest
            python-version: "3.8"  # Don't test Python 3.8 on Windows
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        
    - name: Install system dependencies
      if: runner.os != 'Windows'  # Skip on Windows
      run: |
        sudo apt-get update
        sudo apt-get install -y ${{ matrix.extra-pkg }}
        
    - name: Run tests
      run: |
        python -m pip install pytest
        python -m pytest tests/
        
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()  # Upload even if tests fail
      with:
        name: test-results-${{ matrix.os }}-py${{ matrix.python-version }}
        path: test-reports/
```

#### Let's walk through the **step-by-step flow and execution logic** of this GitHub Actions matrix workflow ‚Äî **visually and descriptively**.

---

## üîÅ Trigger

### ‚úÖ **When does it run?**

```yaml
on: [push]
```

* Runs **automatically whenever someone pushes code** to any branch in the repo.

---

## üîÑ Matrix Breakdown

### üßÆ **Matrix Inputs:**

```yaml
os: [ubuntu-latest, macos-latest, windows-latest]
python-version: ["3.8", "3.9", "3.10"]
```

This results in 3 √ó 3 = 9 jobs **before filtering**.

---

### üîç Matrix `include` (adds extra data):

```yaml
include:
  - os: ubuntu-latest     ‚û° extra-pkg: python3-dev
  - os: macos-latest      ‚û° extra-pkg: openssl
  - os: windows-latest    ‚û° extra-pkg: python
```

Each job gets an **`extra-pkg`** value based on its OS.

---

### ‚ùå Matrix `exclude` (removes one case):

```yaml
exclude:
  - os: windows-latest
    python-version: "3.8"
```

Now only 8 jobs run (1 excluded).

---

## üìä FINAL MATRIX JOBS (8 total):

| OS             | Python Version | Extra Package |
| -------------- | -------------- | ------------- |
| ubuntu-latest  | 3.8            | python3-dev   |
| ubuntu-latest  | 3.9            | python3-dev   |
| ubuntu-latest  | 3.10           | python3-dev   |
| macos-latest   | 3.8            | openssl       |
| macos-latest   | 3.9            | openssl       |
| macos-latest   | 3.10           | openssl       |
| windows-latest | 3.9            | python        |
| windows-latest | 3.10           | python        |

---

## üß≠ Flow Diagram of Execution

```text
Trigger: push
   ‚îÇ
   ‚îî‚îÄ‚îÄ‚ñ∫ Starts job: test (matrix strategy)
             ‚îÇ
             ‚îú‚îÄ‚îÄ‚ñ∫ ubuntu-latest + 3.8 + python3-dev
             ‚îú‚îÄ‚îÄ‚ñ∫ ubuntu-latest + 3.9 + python3-dev
             ‚îú‚îÄ‚îÄ‚ñ∫ ubuntu-latest + 3.10 + python3-dev
             ‚îú‚îÄ‚îÄ‚ñ∫ macos-latest + 3.8 + openssl
             ‚îú‚îÄ‚îÄ‚ñ∫ macos-latest + 3.9 + openssl
             ‚îú‚îÄ‚îÄ‚ñ∫ macos-latest + 3.10 + openssl
             ‚îú‚îÄ‚îÄ‚ñ∫ windows-latest + 3.9 + python
             ‚îî‚îÄ‚îÄ‚ñ∫ windows-latest + 3.10 + python
```

Each job runs **independently and in parallel** (unless you define `needs:`).

---

## üß± Step-by-Step Execution *within each matrix job*

### Step 1: ‚úÖ Checkout Code

```yaml
- uses: actions/checkout@v4
```

Pulls your repo code onto the runner machine.

---

### Step 2: ‚òï Set Up Python

```yaml
- uses: actions/setup-python@v4
  with:
    python-version: ${{ matrix.python-version }}
```

Sets the Python version for that job (3.8 / 3.9 / 3.10).

---

### Step 3: üîß Install System Packages (only if not Windows)

```yaml
- run: sudo apt-get install -y ${{ matrix.extra-pkg }}
  if: runner.os != 'Windows'
```

* Linux/macOS: installs required system dependencies.
* Windows: **skips this step**.

---

### Step 4: üß™ Run Tests

```yaml
- run: |
    python -m pip install pytest
    python -m pytest tests/
```

* Installs `pytest`
* Executes tests in the `tests/` directory.

---

### Step 5: üì¶ Upload Artifacts (even if tests fail)

```yaml
- uses: actions/upload-artifact@v3
  if: always()
  with:
    name: test-results-${{ matrix.os }}-py${{ matrix.python-version }}
    path: test-reports/
```

* Uploads test results even if the test fails.
* Artifact is named using OS + Python version for clarity.

---

## üß≠ Visual Summary

```mermaid
graph TD
    A[Push Trigger] --> B[Matrix Strategy]
    B --> C1[ubuntu + 3.8]
    B --> C2[ubuntu + 3.9]
    B --> C3[ubuntu + 3.10]
    B --> C4[macos + 3.8]
    B --> C5[macos + 3.9]
    B --> C6[macos + 3.10]
    B --> C7[windows + 3.9]
    B --> C8[windows + 3.10]

    C1 --> D1[Checkout Code]
    D1 --> E1[Setup Python]
    E1 --> F1[Install extra-pkg]
    F1 --> G1[Run Tests]
    G1 --> H1[Upload Results]

    C7 --> D7[Checkout Code]
    D7 --> E7[Setup Python]
    E7 --> F7[Skip Install]  --> G7[Run Tests] --> H7[Upload Results]
```

---




## Key Components:

1. **Matrix Definition**:
   - `os`: Tests run on Ubuntu, macOS, and Windows
   - `python-version`: Tests with Python 3.8, 3.9, and 3.10
   - `include`: Adds extra variables specific to each OS
   - `exclude`: Skips Python 3.8 tests on Windows

2. **Job Execution**:
   - This creates 8 jobs (3 OS √ó 3 Python versions, minus 1 excluded combination)
   - Each job gets its combination of `os`, `python-version`, and `extra-pkg`

3. **Accessing Matrix Values**:
   - Use `${{ matrix.variable-name }}` to access matrix values in steps
   - Example: `${{ matrix.os }}` and `${{ matrix.python-version }}`

## Advanced Matrix Features:

1. **Dynamic Matrices** (from outputs):
```yaml
strategy:
  matrix:
    version: ${{ fromJSON(needs.setup.outputs.versions) }}
```

2. **Fail Fast**:
```yaml
strategy:
  fail-fast: true  # Stop all jobs if one fails (default)
  # or false to continue other jobs if one fails
```

## Official Documentation References:

- [Using a matrix for your jobs](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs)
- [Workflow syntax for jobs.<job_id>.strategy.matrix](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix)

This example demonstrates matrix usage for cross-platform testing without npm, showing how to test Python code across different operating systems and language versions while handling platform-specific requirements.

####  Let's clarify how the *matrix strategy* works in GitHub Actions, especially in the context of using *different Node.js versions* in the same workflow.

---

### üí° Your Matrix Strategy

yaml
jobs:
  node-matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [14, 15, 16]
    steps:
      - run: node -v
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - run: node -v


---

### ‚ùìDoes Each Job Run on the Same or Different Runners?

*Each matrix job runs on a separate runner instance.*

* *GitHub creates a new virtual machine (runner)* for each combination defined in your matrix.
* That means:

  * Job with Node.js 14 runs on *VM 1*
  * Job with Node.js 15 runs on *VM 2*
  * Job with Node.js 16 runs on *VM 3*

---

### ‚úÖ Why This Works

You are correct that you *can‚Äôt install multiple Node.js versions on the same environment at once* without overriding or managing them manually (e.g., with nvm). 

But GitHub Actions avoids that problem by *spinning up a fresh environment per matrix entry*.

* Each job *starts clean* with its own OS instance.
* There‚Äôs *no interference or overwrite*, even if all jobs use the same runs-on: ubuntu-latest.

---

### üîÅ Flow (Simplified)

1. *Matrix expansion*: GitHub generates 3 jobs:

   * node-version: 14
   * node-version: 15
   * node-version: 16

2. *Each job*:

   * Gets a fresh Ubuntu VM.
   * Installs the specified Node.js version via actions/setup-node@v3.
   * Runs the commands you defined.

---

### üß† Summary

* ‚úÖ Each matrix combination runs in a *separate GitHub-hosted runner*.
* ‚úÖ You *can safely use different Node.js versions* without conflict.
* ‚ùå The jobs do *not* run in the same runner, so there is *no version overwrite* issue.

Let me know if you'd like a diagram showing this visually.

## üß∑ Real-World Use Cases:

* Testing an Ansible playbook across multiple OSes.
* Running Terraform plan against different workspaces.
* Validating Bash scripts with multiple input parameters.

---

## üîó Official Docs:

* Matrix strategy documentation:
  [https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs)

---


