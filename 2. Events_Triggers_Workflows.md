# Workflow Triggers and Repository Events Explained with Examples

Workflow triggers are events that initiate automated processes (workflows) in software development and DevOps pipelines. Repository events are specific types of triggers that occur within a version control repository. Let me explain with practical examples.

[REFERENCE](https://docs.github.com/en/actions/reference/events-that-trigger-workflows)

## 1. Common Workflow Triggers

### Example 1: Push to a Branch (GitHub Actions)

```yaml
# .github/workflows/build-on-push.yml
name: Build and Test on Push

on:
  push:
    branches:
      - main      # Trigger when code is pushed to main branch
      - feature/* # Trigger when code is pushed to any branch starting with "feature/"

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm ci
          
      - name: Run tests
        run: npm test
```

![image](https://github.com/user-attachments/assets/03f1880f-b9ee-422c-8072-bd3075bca338)


**Real-life scenario**: Whenever developers push code to the main branch or any feature branch, this workflow automatically runs tests to ensure no breaking changes were introduced.

### Example 2: Pull Request Events

```yaml
# .github/workflows/pr-checks.yml
name: PR Quality Checks

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run lint
        
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check for vulnerabilities
        uses: actions/npm-audit@v1
        with:
          command: audit
          args: --audit-level=moderate
```

**Real-life scenario**: When a developer opens a new pull request or updates an existing one targeting the main branch, this workflow runs code linting and security checks to maintain code quality.

## 2. Repository Events

### Example 3: Issue Comment Trigger

```yaml
# .github/workflows/issue-comment.yml
name: Respond to Issue Comments

on:
  issue_comment:
    types: [created]

jobs:
  respond:
    runs-on: ubuntu-latest
    steps:
      - name: Check if comment contains "/deploy"
        if: contains(github.event.comment.body, '/deploy')
        run: |
          echo "Deployment requested by @${{ github.event.comment.user.login }}"
          # Add your deployment logic here
          echo "Deployment started!"
```
Here's a **step-by-step guide** to implement the **GitHub Actions workflow triggered by `/deploy` comment** on an issue or pull request:

---

## ✅ **Step 1: Create the Workflow File**

1. Go to your repository.
2. Navigate to: `.github/workflows/`
3. Create a new file: `issue-comment.yml`

### Paste the following content:

```yaml
# .github/workflows/issue-comment.yml
name: Respond to Issue Comments

on:
  issue_comment:
    types: [created]

jobs:
  respond:
    runs-on: ubuntu-latest
    steps:
      - name: Check if comment contains "/deploy"
        if: contains(github.event.comment.body, '/deploy')
        run: |
          echo "Deployment requested by @${{ github.event.comment.user.login }}"
          # Simulate deployment
          echo "Deployment started!"
```

---

## ✅ **Step 2: Commit and Push the File**

* Commit the file:

  ```bash
  git add .github/workflows/issue-comment.yml
  git commit -m "Add workflow to respond to /deploy comments"
  git push
  ```

---

## ✅ **Step 3: Create an Issue or PR**

* Go to the repository on GitHub.
* Create a new **issue** or **pull request**.

---

## ✅ **Step 4: Add a Comment with `/deploy`**

* In the issue or PR, comment:

  ```
  /deploy
  ```

This triggers the workflow.

---

![image](https://github.com/user-attachments/assets/02d99163-f0c2-464c-b692-7c15aeb4edc3)

![image](https://github.com/user-attachments/assets/5e085a53-395c-451d-825c-141e6757450e)



## ✅ **Step 5: Check Workflow Runs**

* Go to the **Actions** tab in your repository.
* Look for the workflow named `Respond to Issue Comments`.
* Click the latest run and see the logs.


![image](https://github.com/user-attachments/assets/00633894-8824-4518-93df-d5c75e02d4c9)



---

## ✅ **(Optional) Step 6: Add Real Deployment Logic**

Replace:

```bash
echo "Deployment started!"
```

With actual deployment commands, such as:

```bash
./deploy.sh
```

or call a script, send a webhook, or trigger an external service.

---

## ✅ **Step 7: Restrict to Specific Users (Optional)**

You can allow only certain users to trigger deployment, for example:

```yaml
if: contains(github.event.comment.body, '/deploy') && github.event.comment.user.login == 'deepak'
```

---

---
**Real-life scenario**: When a team member comments "/deploy" on an issue, this workflow can trigger a deployment process, useful for staging environments.

### Example 4: Scheduled Events (Cron Jobs)

```yaml
# .github/workflows/nightly-build.yml
name: Nightly Build and Test

on:
  schedule:
    - cron: '0 3 * * *' # 3 AM UTC every day
  workflow_dispatch: # Allow manual triggering

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run build
      - run: npm run test:all
      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: test-results.xml
```

**Real-life scenario**: This workflow runs a comprehensive test suite every night at 3 AM UTC, ensuring that the codebase remains stable even if some tests are too slow to run on every commit.

### Example 5: Release Published Event

```yaml
# .github/workflows/release.yml
name: Process Release

on:
  release:
    types: [published]

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1
        with:
          slack-message: 'New release ${{ github.event.release.tag_name }} published!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
          
  docker:
    runs-on: ubuntu-latest
    needs: notify
    steps:
      - uses: actions/checkout@v4
      - name: Build Docker image
        run: docker build -t myapp:${{ github.event.release.tag_name }} .
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
      - name: Push to Docker Hub
        run: docker push myapp:${{ github.event.release.tag_name }}
```

**Real-life scenario**: When a new release is published in GitHub, this workflow notifies the team via Slack and automatically builds and pushes a Docker image tagged with the release version.

## 3. Advanced Example: Combined Events

```yaml
# .github/workflows/full-ci-cd.yml
name: Full CI/CD Pipeline

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'       # Only trigger if changes are in src directory
      - 'package.json' # Or if package.json changes
  pull_request:
    branches:
      - main
  schedule:
    - cron: '0 5 * * 1' # Every Monday at 5 AM UTC

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm test
      - uses: codecov/codecov-action@v3
        if: success()
        
  deploy:
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run build
      - name: Deploy to AWS
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - run: aws s3 sync ./dist s3://my-production-bucket --delete
```

**Real-life scenario**: This comprehensive workflow:
1. Runs tests on every push to main or pull request targeting main (but only if changes are in src/ or package.json)
2. Runs a weekly test on Mondays
3. Only deploys to production when code is pushed directly to main (not via PR)
4. Uploads test coverage to Codecov
5. Deploys built assets to AWS S3

These examples demonstrate how workflow triggers and repository events can automate various aspects of the software development lifecycle, from testing to deployment and notifications.

---

# Running a Workflow Based on Another Workflow in GitHub Actions

GitHub Actions allows you to trigger workflows based on the completion of other workflows using the `workflow_run` event. This is useful for creating dependent workflows or orchestrating a sequence of actions.

## How `workflow_run` Works

The `workflow_run` event triggers when a workflow run reaches a "completed" state (success, failure, or neutral). The dependent workflow will have access to the triggering workflow's artifacts and outputs.


## Example Scenario

Let's say you have:
1. A "Build and Test" workflow that runs on push to main branch
2. A "Deploy" workflow that should run only after "Build and Test" succeeds

### Workflow 1: Build and Test (.github/workflows/build-test.yml)
```yaml
name: Build and Test

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Build
        run: echo "Building the application..."
        
      - name: Run Tests
        run: echo "Running tests..."
```

### Workflow 2: Deploy (.github/workflows/deploy.yml)
```yaml
name: Deploy

on:
  workflow_run:
    workflows: ["Build and Test"]
    types:
      - completed
    branches: [ main ]

jobs:
  deploy:
    # Only run if the triggering workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to Production
        run: echo "Deploying to production server..."
```

## Key Points

1. The `workflow_run` event watches for the specified workflow ("Build and Test" in this case)
2. The `types: completed` means it triggers when the workflow finishes (regardless of success/failure)
3. We use a condition (`if`) to only proceed with deployment if the build succeeded
4. Both workflows must be in the same repository for this to work

## Alternative: Reusable Workflows

Another approach is to use reusable workflows where you can directly call one workflow from another:

### Reusable Workflow (.github/workflows/build-test.yml)
```yaml
name: Build and Test

on:
  workflow_call:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Building..."
      - run: echo "Testing..."
```

### Caller Workflow (.github/workflows/deploy.yml)
```yaml
name: Deploy Pipeline

on: [push]

jobs:
  build-test:
    uses: ./.github/workflows/build-test.yml
    
  deploy:
    needs: build-test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Deploying..."
```

![image](https://github.com/user-attachments/assets/ed6f2613-c139-4288-8cdd-adf87685dc6e)

![image](https://github.com/user-attachments/assets/484bf7d4-f1c3-4940-89d0-ce6f2233b58b)

![image](https://github.com/user-attachments/assets/4fbf1950-3188-445a-a167-6899bb2bf5ee)

![image](https://github.com/user-attachments/assets/7c13ce7a-76aa-4f4e-8b89-0d9db64b4442)


This approach provides more direct control over the workflow sequence.

Let me break down how this connection works chronologically and technically:

## The Connection Mechanism

1. **Event-Based Triggering**: 
   - The `workflow_run` event establishes a parent-child relationship between workflows
   - The "Deploy" workflow subscribes to completion events from the "Build and Test" workflow

2. **Two-Level Filtering**:
   - First filter: GitHub watches for ANY completion of "Build and Test" on main branch (from `workflow_run` config)
   - Second filter: The job specifically checks for SUCCESSFUL completion (from `if` condition)

## Chronological Execution Flow

Here's what happens step-by-step:

1. **Initial Trigger**:
   - Someone pushes to the `main` branch
   - This triggers the "Build and Test" workflow automatically (via its `on: push` trigger)

2. **Build Process**:
   - "Build and Test" runs its jobs (building and testing the code)
   - When it finishes, it reaches a "conclusion" (success, failure, cancelled, etc.)

3. **Event Emission**:
   - GitHub generates a `workflow_run` event with all details about the completed run
   - This event includes the `conclusion` status (success/failure/etc.)

4. **Deploy Workflow Trigger**:
   - GitHub checks all workflows that subscribe to `workflow_run` events for "Build and Test"
   - Our "Deploy" workflow matches, so it starts running

5. **Conditional Execution**:
   - Before running the `deploy` job, GitHub evaluates the `if` condition:
     ```yaml
     if: ${{ github.event.workflow_run.conclusion == 'success' }}
     ```
   - Only if the build succeeded does the deploy job actually execute

## Key Technical Details

1. **Event Payload**:
   The `github.event.workflow_run` object contains:
   ```json
   {
     "conclusion": "success", // or "failure", "cancelled", etc.
     "status": "completed",
     "html_url": "https://github.com/.../actions/runs/12345",
     "id": 12345,
     // ... other metadata
   }
   ```

2. **Timing Considerations**:
   - There's typically a 1-2 minute delay between workflows
   - The deploy workflow sees the COMPLETE result (never a partial/in-progress state)

3. **Security Context**:
   - The triggered workflow runs with the same permissions as the original
   - It has access to the repository at the EXACT commit that the build ran against

## Visual Timeline

```
[Push Event] 
  → [Build & Test Starts] 
    → [Build Jobs Run] 
      → [Build Completes (success/failure)] 
        → [GitHub emits workflow_run event]
          → [Deploy Workflow Triggers]
            → [Checks conclusion]
              → [Runs only if success]
```

This ensures your deployment only happens when the build succeeds, creating a safe CI/CD pipeline.

## Key Points

1. **Workflow Name Matching**: The `workflows` value must exactly match the name of the workflow you want to trigger from.

2. **Branch Filtering**: The dependent workflow will only run if the triggering workflow ran on a branch that matches the specified branch filter.

3. **Conclusion Check**: Use `github.event.workflow_run.conclusion` to check if the previous workflow succeeded.

4. **Artifact Access**: You can access artifacts from the triggering workflow using the `workflow` parameter in `download-artifact`.

## Alternative: Using Workflow Dispatch

If you need more control, you can have the first workflow trigger the second one using a `repository_dispatch` or `workflow_dispatch` event:

```yaml
# In the test workflow, add this step at the end if tests pass:
- name: Trigger deploy workflow
  if: success()
  uses: actions/github-script@v6
  with:
    script: |
      github.rest.actions.createWorkflowDispatch({
        owner: context.repo.owner,
        repo: context.repo.repo,
        workflow_id: 'deploy.yml',
        ref: 'main'
      })
```

This approach gives you more flexibility but requires additional permissions.

---

# Filtering GitHub Actions Workflow Runs by Branches, Tags, and Paths

GitHub Actions provides powerful filtering options to control when your workflows run based on branches, tags, and file paths that changed. Here's how to use these filters with practical examples:

## 1. Branch Filtering

### Example: Run only on main and develop branches
```yaml
on:
  push:
    branches:    
      - main
      - develop
```

### Example: Exclude specific branches
```yaml
on:
  push:
    branches-ignore:
      - temp/*
      - experimental/*
```

## 2. Tag Filtering

### Example: Run only for semantic version tags
```yaml
on:
  push:
    tags:
      - v[0-9]+.[0-9]+.[0-9]+  # Matches v1.0.0, v2.3.4, etc.
```

### Example: Run for specific tag patterns
```yaml
on:
  push:
    tags:
      - release-*
```

## 3. Path Filtering

### Example: Run only when specific files change
```yaml
on:
  push:
    paths:
      - 'src/**'           # Any file in src directory
      - '*.py'             # Any Python file in root
      - 'config/*.yaml'    # YAML files in config directory
```

### Example: Ignore changes to documentation
```yaml
on:
  push:
    paths-ignore:
      - 'docs/**'
      - 'README.md'
```

## Combined Example

Here's a workflow that combines all three filter types:

```yaml
name: Build and Deploy

on:
  push:
    branches:
      - main
      - feature/*
    tags:
      - v*
    paths:
      - 'src/**'
      - 'Dockerfile'
    paths-ignore:
      - '**/*.md'
      - 'docs/**'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Build
        run: echo "Building application..."
        
      - name: Package
        run: echo "Creating deployment package..."
```

## Advanced Filtering with `if` Conditions

You can add additional runtime filtering:

```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest
    if: |
      github.ref == 'refs/heads/main' ||
      startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4
      - run: echo "Deploying..."
```

[Reference Links](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet)

## Important Notes

1. **Path filtering** only works for push/pull_request events
2. **Branch/tag patterns** support glob patterns:
   - `feature/*` matches all branches starting with "feature/"
   - `release-*` matches all tags starting with "release-"
3. **Evaluation order**: GitHub first checks branch/tag filters, then path filters
4. **Special cases**:
   - Push to a new branch: path filters won't work (no previous commit to compare)
   - Force push: path filters may behave unexpectedly

These filters help optimize your CI/CD pipeline by running workflows only when relevant changes occur.

# Manually Triggering GitHub Actions Workflows  

You can manually trigger workflows in GitHub Actions through:  
1. **GitHub Web UI** (Repository UI)  
2. **GitHub CLI** (`gh`)  
3. **GitHub REST API**  

---

## **1. Triggering via GitHub Web UI (Workflow Dispatch)**  

### **Step 1: Configure `workflow_dispatch` in YAML**  
Add `workflow_dispatch` to the `on` trigger in your workflow file (`.github/workflows/manual_trigger.yml`):  

```yaml
name: Manual Trigger Example

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deploy environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: 'Force deploy (skip checks)?'
        required: false
        default: 'false'
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Print inputs
        run: |
          echo "Deploying to ${{ github.event.inputs.environment }}"
          echo "Force deploy? ${{ github.event.inputs.force_deploy }}"
      - name: Run deployment steps
        run: echo "Deploying to ${{ github.event.inputs.environment }}..."
```

### **Step 2: Manually Run from GitHub UI**  
1. Go to **Actions** tab in your repo  
2. Select the workflow (e.g., **Manual Trigger Example**)  
3. Click **Run workflow**  
4. Fill in inputs (if defined) and click **Run workflow**  

![image](https://github.com/user-attachments/assets/f8340da4-8ced-4e2e-aec5-a472342a0c59)


---

## **2. Triggering via GitHub CLI (`gh`)**  

### **Step 1: Install GitHub CLI**  
```bash
brew install gh  # macOS (Homebrew)
winget install --id GitHub.cli  # Windows
sudo apt install gh && gh auth login  # Linux
```

### **Step 2: Trigger Workflow via CLI**  
```bash
gh workflow run manual_trigger.yml \
  --ref main \
  -f environment=production \
  -f force_deploy=true
```

**Explanation:**  
- `gh workflow run <workflow-file>` → Triggers the workflow  
- `--ref main` → Runs on the `main` branch  
- `-f` → Passes inputs (matches YAML `inputs`)  

---

## **3. Triggering via GitHub REST API**  

### **Step 1: Get Workflow ID**  
```bash
curl -s -H "Authorization: token YOUR_GITHUB_TOKEN" \
  "https://api.github.com/repos/OWNER/REPO/actions/workflows" | jq '.workflows[] | select(.name == "Manual Trigger Example") | .id'
```
*(Replace `YOUR_GITHUB_TOKEN`, `OWNER`, `REPO`)*  

### **Step 2: Trigger Workflow via API**  
```bash
curl -X POST \
  -H "Authorization: token YOUR_GITHUB_TOKEN" \
  -H "Accept: application/vnd.github.v3+json" \
  "https://api.github.com/repos/OWNER/REPO/actions/workflows/WORKFLOW_ID/dispatches" \
  -d '{
    "ref": "main",
    "inputs": {
      "environment": "production",
      "force_deploy": true
    }
  }'
```
*(Replace `WORKFLOW_ID` from Step 1)*  

---

- [GitHub Actions Events that Trigger Workflows - workflow_dispatch](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_dispatch)
- [GitHub CLI Manual - gh_workflow_run](https://cli.github.com/manual/gh_workflow_run)
- [GitHub REST API - Create a workflow dispatch event](https://docs.github.com/en/rest/actions/workflows?apiVersion=2022-11-28#create-a-workflow-dispatch-event)

## **Summary of Methods**  

| Method | Command/UI | Best For |
|--------|-----------|----------|
| **GitHub Web UI** | Click **Run workflow** | Manual testing, quick runs |
| **GitHub CLI (`gh`)** | `gh workflow run` | Scripting, local triggers |
| **REST API** | `POST /workflows/{id}/dispatches` | Automation, CI/CD integrations |

All methods require `workflow_dispatch` in the YAML. You can pass inputs for dynamic behavior! 🚀

---
